# Unidad 2

## ðŸ”Ž Fase: Set + Seek

### Actividad 1

**Â¿CÃ³mo funciona la suma dos vectores en p5.js?**

La suma de vectores estÃ¡ dada por el mÃ©todo .add, la cual sirve para sumar vectores en este lenguaje y para utilizarlo se puede hacer de dos maneras: 
- La primera es sumar componente a componente de dos vectores: AquÃ­ lo que hacemos es que modificamos v1 sumandole las componentes del v2.
  
  ```js
  let v1 = createVector(3, 4);
  let v2 = createVector(1, 2);

  v1.add(v2);
  ```
- Otra manera de sumar vectores es sumarle componentes individuales. 

  ```js
  let v1 = createVector(3, 4);
  
  v1.add(1,2)
  ```
y lo que hace es que le suma los nuevos valores a las componentes del vector respectivamente; para el componente X serÃ­a 3+1=4 y para Y serÃ­a 4+2= 6. Las nuevas componentes serian v1= (4,6).

**Â¿Por quÃ© esta lÃ­nea position = position + velocity; no funciona?**

En JavaScript, el operador + no sabe sumar objetos p5.Vector y .add() estÃ¡ definido explÃ­citamente para hacer suma vectorial.

[Link para ver el ejemplo comentado de la clase](https://editor.p5js.org/manuuuu15281/sketches/e307PnlQP)

### Actividad 2
Para desarrolar esta actividad utilicÃ© el ejemplo del random Walker. Para hacer que el cÃ³digo funcionara con vectores en la clase walker creÃ© una variable donde almacenÃ© la direcciÃ³n del vector en X y Y. TambiÃ©n  en el show() modificamos los parametos de point() y le aÃ±adimos el nuevo nombre (position) para que los reconociera con el nuevo cambio (la variable que creÃ© en Walker se llama this.position) y por Ãºltimo le agreguÃ© a los condicionales el nombre position. 

```js
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com

let walker;

function setup() {
  createCanvas(640, 240);
  walker = new Walker();
  background(255);
}

function draw() {
  walker.step();
  walker.show();
}

class Walker {
  constructor() {
    
    this.position=createVector(width/2, height /2);//No se me puede olvidar el this e indica que es un miembro del objeto
  }

  show() {
    stroke(0);
    point(this.position.x, this.position.y);
  }

  step() {
  
    const choice = floor(random(4));
    if (choice == 0) {
      this.position.x++;
    } else if (choice == 1) {
      this.position.x--;
    } else if (choice == 2) {
      this.position.y++;
    } else {
      this.position.y--;
    }
  }
}

```
### Actividad 3

Cuando analizamos este cÃ³digo en la clase, pensÃ© que el cÃ³digo iba a imprimir primero el vector con la direcciÃ³n (6,9) y luego esos valores serian modificados y volveria a imprimir el vector pero con los valores actualizados. Efectivamente asÃ­ sucediÃ³, y tenÃ­a sentido por la explicaciÃ³n del cÃ³digo que el profe diÃ³ y los console.log que hay en el cÃ³digo. 

**Paso por valor en programaciÃ³n:**
Este aÃºn no me quedÃ³ tan claro, pero investigando lleguÃ© a que es cuando pasas cosas como argumentos en funciones, JavaScript crea una copia del valor. Por tanto, cualquier cambio dentro de la funciÃ³n no afecta al valor original fuera de ella.

Un ejemplo puede ser: 

```js
function cambiarValor(x) {
  x = x + 1;
  console.log("Dentro de la funciÃ³n:", x);
}

let numero = 5;
cambiarValor(numero);
console.log("Fuera de la funciÃ³n:", numero);
```

**Paso por referencia en programaciÃ³n:**

Este lo entendÃ­ muy bien por la explicaciÃ³n del profe en la clase y es cuando pasamos objetos por referencia lo que se estÃ¡ pasando es una referencia a la ubicaciÃ³n en memoria del objeto original (que es lo que sucede en el cÃ³digo del ejemplo que el profe diÃ³ en clase antes de modificarlo). Esto quiere decir que si modificas las propiedades del objeto dentro de la funciÃ³n, esto si afectarÃ¡ al objeto original. Investigando un poco de cÃ³mo funcionaba esta manera de programar, encontrÃ© que los tipos de referencias que se pueden pasar son **Object, Array y Function**. 

Un ejemplo de esto: 
```js
function modificarObjeto(obj) {
  obj.nombre = "Ana";
}

let persona = { nombre: "Luis" };
modificarObjeto(persona);
console.log("DespuÃ©s de la funciÃ³n:", persona.nombre)
```
En el ejemplo queda en evidencia cÃ³mo pasamos como una referencia el nombre "ana" y se modificÃ³ el contenido original de la variable persona. 

En el cÃ³digo que el profe nos enseÃ±Ã³ en clase se estÃ¡ aplicando paso por referencia y se evidencia tal cual lo que pasa en el ejemplo anterior. El profe luego hizo algunas modificaciones que nos ayudÃ³ a comprender cÃ³mo podiamos hacer un traspaso por referencia pero sin modificar el arreglo original. 

De esa actividad recordÃ© el concepto de paso por valor y por referencia, tambiÃ©n comprendÃ­ cÃ³mo hacer una copia de un array y trabajar sobre esta sin modificar el arreglo original. 

### Actividad 4

- **Â¿Para quÃ© sirve el mÃ©todo mag()? Nota que hay otro mÃ©todo llamado magSq(). Â¿CuÃ¡l es la diferencia entre ambos? Â¿CuÃ¡l es mÃ¡s eficiente?**

  El mÃ©todo mag() sirve para calcular la magnitud de un vector en dos dimensiones (x , y) y este aplica la raÃ­z cuadrada al calculo de la magnitud. Por su lado, el mÃ©todo magSq() calcula la magnitud del vector pero a diferencia de mag()  este devuelve lo que queda dentro de la raÃ­z cuadrada (no la aplica). Lo que quiere decir que la segunda opciÃ³n es mÃ¡s rÃ¡pida porque evita la raÃ­z cuadrada, lo que puede ser Ãºtil en visualizaciones en tiempo real, juegos o simulaciones.

- **Â¿Para quÃ© sirve el mÃ©todo normalize()?**

Este mÃ©todo convierte un vector cualquiera en un vector unitario (un vector unitario es el que tiene magnitud 1) y se usa para indicar direcciones sin importar la distancia o para generar movimientos con velocidad constante. 

- **Te encuentras con un periodista en la calle y te pregunta Â¿Para quÃ© sirve el mÃ©todo dot()? Â¿QuÃ© le responderÃ­as en un frase?**

  Bro sirve para calcular el producto punto entre dos vectores, tambiÃ©n te dice que tan alineados estÃ¡n dos vectores entre si.

  Y si me sigue preguntando le digo:  sirve tambiÃ©n para ver si dos vectores se mueven en la misma direcciÃ³n (dot > 0), en direcciones       opuestas (dot < 0), o si son perpendiculares (dot = 0).

- **El mÃ©todo dot() tiene una versiÃ³n estÃ¡tica y una de instancia. Â¿CuÃ¡l es la diferencia entre ambas?**

  La diferencia entre la versiÃ³n estÃ¡tica y la versiÃ³n de instancia del mÃ©todo dot() en p5.js tiene que ver con cÃ³mo se llama al mÃ©todo y dÃ³nde se coloca el vector base, pero hacen exactamnete lo mismo pero con sintaxis diferentes:
  
  1. **Version instancia:** se llama desde un vector en especÃ­fico, y calcula el producto punto con otro vector que se pone como argumento.
     
     ```js
       let v1 = createVector(1, 2);
       let v2 = createVector(3, 4);
       let resultado = v1.dot(v2); // dot entre v1 y v2
     ```
  2. **Version estÃ¡tica:** Esta version llama directamnete desde la clase p5.vector y no depende de ninguna instancia. Necesita dos vectores como argumentos.
     
     ```js
       let v1 = createVector(1, 2);
       let v2 = createVector(3, 4);
       let resultado = p5.Vector.dot(v1, v2);
     ```

- **Ahora el mismo periodista curioso de antes te pregunta si le puedes dar una intuiciÃ³n geomÃ©trica acerca del producto cruz. Entonces te pregunta Â¿CuÃ¡l es la interpretaciÃ³n geomÃ©trica del producto cruz de dos vectores? Tu respuesta debe incluir quÃ© pasa con la orientaciÃ³n y la magnitud del vector resultante.**

  El producto cruz entre dos vectores da cÃ³mo resultado un vector que sale de manera ortogonal (perpendicular) al plano formado entre los dos vectores originales y ademÃ¡s su magnitud es igual al Ã¡rea del pararelogramo que se forma con esos dos vectores base.

- **Â¿Para que te puede servir el mÃ©todo dist()?**

  Este mÃ©todo nos sirve para calcular la distancia que hay entre dos puntos, lo puede hacer mediante coordenadas o vectores. Puede ser muy Ãºtil para detectar si el mouse estÃ¡ cerca de algÃºn objeto y quiero agregar alguna interactividad o dibujar lÃ­neas o curvas entre puntos que estÃ©n a cierta distancia.

- **Â¿Para quÃ© sirven los mÃ©todos normalize() y limit()?**

  El mÃ©todo normalize() sirve para convertir cualquier vector en un vector unitario (ayuda si necesitamos tener movimientos con velocidades constantes). Por su lado el mÃ©todo limit() permite "cortar" la magnitud de un vector para evitar que pase de una velocidad o fuerza mÃ¡xima pero siempre mantiene su direcciÃ³n.


### Actividad 5

**CÃ³digo de p5.js**

```js
let tiempo = 0;

let mover = 1; 

function setup() {
    createCanvas(400, 400);
}

function draw() {
    background(200);
  
   translate(50, 50); // trasladar el punto de origen a las coordenadas (50,50)
  
    let v0 = createVector(0, 0); // este en el 0,0
    let v1 = createVector(300, 0);
    let v2 = createVector(0, 300);
    let v4 = createVector(-300,300);
    let v3 = p5.Vector.lerp(v1, v2, tiempo);
  
    
    let red1= color(255,0,0);
    let blue1= color(0,0,255);
    let degradado = lerpColor(blue1, red1, mover);
  
  
  
    //lerpColor(c1, c2, amt)
  
  tiempo+= 0.01*mover;
   
  if (tiempo <=0) 
    {
      
      mover =1;
    }
  if ( tiempo >=1)
    {
      mover=-1;
    }
  
    drawArrow(v0, v1, 'red');
    drawArrow(v0, v2, 'blue');
    drawArrow(v1, v4, 'green');
    drawArrow(v0, v3, 'purple');
    drawArrow(v0, v3, degradado);
  
}



function drawArrow(base, vec, myColor) {
    push();
    stroke(myColor);
    strokeWeight(3);
    fill(myColor);
    translate(base.x, base.y);
    line(0, 0, vec.x, vec.y);
    rotate(vec.heading());
    let arrowSize = 7;
    translate(vec.mag() - arrowSize, 0);
    triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
    pop();
}
```

- **Â¿CÃ³mo funciona lerp() y lerpColor() ?**

  lerp() es una funciÃ³n que se usa para hacer interpolaciÃ³n lineal entre dos coordenadas o valores numÃ©ricos. Por su parte, el mÃ©todo lerpColor() se usa para hacer interpolaciones de color (hacer una mezcla gradual).

  En mi caso no logrÃ© implementar bien el lepColor() y aunque intentÃ© arreglarlo,  no me funcionÃ³ (cambia entre rojo y azul drasticamente y no crea la interpolaciÃ³n)

 - **Â¿CÃ³mo se dibuja una flecha usando drawArrow()**

   Para usar la funciÃ³n drawArrow() debemos entender cÃ³mo llamarla:  drawArrow(v0, v1, 'red');
   v0 = a la base, la coordenada a la que se traslada el plano cartesiano.
   v1 = es la coordenada que indica el punto destino final del vector creado.
   'red' = es el color de la flecha.

   Para poder llamarla para que funcione, debemos entender cÃ³mo funciona internamente:

```js
   
   function drawArrow(base, vec, myColor) {
    push(); // Guarda el estado actual de estilo y coordenadas

    stroke(myColor);       // Color del contorno de la flecha
    strokeWeight(3);       // Grosor de la lÃ­nea
    fill(myColor);         // Color de relleno (para la punta de flecha)

    translate(base.x, base.y); // Mueve el sistema de coordenadas al punto base

    line(0, 0, vec.x, vec.y); // Dibuja una lÃ­nea desde el origen (relativo) hasta la punta del vector

    rotate(vec.heading()); // Rota el sistema segÃºn el Ã¡ngulo del vector (para alinear la punta de flecha)
    
    let arrowSize = 7;     // TamaÃ±o de la punta de flecha

    translate(vec.mag() - arrowSize, 0); // Mueve hasta casi el final del vector
    triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0); // Dibuja la punta triangular

    pop(); // Restaura el estado original }

```

### Actividad 6

**Â¿CuÃ¡l es el concepto del marco motion 101 y cÃ³mo se interpreta geomÃ©tricamente?**

El concepto de Motion 101 sirve para entender cÃ³mo representar y simular el movimiento de un objeto en una simulaciÃ³n basada en la fÃ­sica. Esta simulaciÃ³n estÃ¡ controlada por 3 vectores clave: vector posiciÃ³n, vector velocidad y vector aceleraciÃ³. Este modelo se basa directamente en las leyes del movimiento de Newton y permite simular movimiento natural de una forma modular y precisa.

Cada cuadro o frame de la simulaciÃ³n sigue ese flujo:

- **1. la aceleraciÃ³n modifica la velocidad**
 
```js
velocity.add(acceleration);
```

- **2. La velocidad modifica la posiciÃ³n**

```js
position.add(velocity);
```

y su respectiva interpretaciÃ³n geometrica es: 

- La position es el punto donde se encuentra el objeto en el espacio.

- velocity es una flecha (vector) que indica hacia dÃ³nde se mueve y quÃ© tan rÃ¡pido.

- acceleration es otra flecha que indica cÃ³mo cambia esa velocidad, ya sea aumentando, disminuyendo o cambiando de direcciÃ³n.

**Â¿CÃ³mo se aplica motion 101 en el ejemplo?**

En el ejemplo podemos ver cÃ³mo la bolita se desplaza gracias a tres vectores (uno de posiciÃ³n, otro de velocidad y uno de la aceleraciÃ³n que se le va aplicando constantemente. Se ve mÃ¡s o menos asÃ­:

- position: posiciÃ³n de la pelota.

- velocity: velocidad con la que se mueve.

- acceleration: aceleraciÃ³n que se aplica constantemente.

Cada cuadro (frame) del programa actualiza estos vectores para simular un movimiento fluido y con comportamiento fÃ­sico bÃ¡sico.

### Actividad 7

Mi ejemplito es un poco bÃ¡sico pero cumple su objetivo de mostrar las diferencias del movimiento de un objeto segÃºn el tipo de aceleraciÃ³n que tenga. Es un objeto en forma de corazÃ³n que se mueve segÃºn el botÃ³n que se presione (los botones son los 3 tipos de aceleraciones). 

Para crear este cÃ³digo yo implementÃ© lo que el profe nos explicÃ³ en clase y lo hice de la misma manera que Ã©l, pero para tener efectos tipo "rebote" o formas de corazÃ³n me ayudÃ© mucho de la IA. 

**CÃ³digo p5.js**

```js
let position, velocity, acceleration;
let modo = 1; // 1: constante, 2: aleatoria, 3: hacia el mouse

let btn1, btn2, btn3;

function setup() {
  createCanvas(600, 400);
  position = createVector(width / 2, height / 2);
  velocity = createVector(0, 0);
  acceleration = createVector(0, 0);

  // Crear botones
  btn1 = createButton('AceleraciÃ³n constante');
  btn1.position(10, height + 10);
  btn1.mousePressed(() => modo = 1);

  btn2 = createButton('AceleraciÃ³n aleatoria');
  btn2.position(170, height + 10);
  btn2.mousePressed(() => modo = 2);

  btn3 = createButton('AceleraciÃ³n hacia el mouse');
  btn3.position(320, height + 10);
  btn3.mousePressed(() => modo = 3);
}

function draw() {
  background(255);

   // 1. AceleraciÃ³n constante (como gravedad)
  if (modo === 1) {
    acceleration = createVector(0, 0.1);
  }

  // 2. AceleraciÃ³n aleatoria
  if (modo === 2) {
    let ax = random(-0.2, 0.2);
    let ay = random(-0.2, 0.2);
    acceleration = createVector(ax, ay);
  }

  // 3. AceleraciÃ³n hacia el mouse
  if (modo === 3) {
    let dir = createVector(mouseX, mouseY);
    dir.sub(position);
    dir.setMag(0.9); // magnitud constante
    acceleration = dir;
  }

  // Motion 101
  velocity.add(acceleration);
  position.add(velocity);

  // Rebotar en los bordes para mantener el corazÃ³n visible
  if (position.x < 0 || position.x > width) {
    velocity.x *= -1;
    position.x = constrain(position.x, 0, width);
  }
  if (position.y < 0 || position.y > height) {
    velocity.y *= -1;
    position.y = constrain(position.y, 0, height);
  }

  drawHeart(position.x, position.y, 20);
}

// FunciÃ³n para dibujar el corazÃ³n
function drawHeart(x, y, size) {
  push();
  translate(x, y);
  fill(255, 0, 100);
  noStroke();
  beginShape();
  vertex(0, -size / 2);
  bezierVertex(size / 2, -size, size, -size / 4, 0, size);
  bezierVertex(-size, -size / 4, -size / 2, -size, 0, -size / 2);
  endShape(CLOSE);
  pop();
}
```

[Link para acceder a mi experimento](https://editor.p5js.org/manuuuu15281/sketches/SdFiL7lpc)

**Â¿QuÃ© observaste cuando usas cada una de las aceleraciones propuestas?**

- Cuando usÃ© la aceleraciÃ³n constente me di cuenta que el corazÃ³n siempre se movÃ­a la misma distancia y de una misma manera, era un movimiento muy tranquilo y controlado.
- Cuando usÃ© la aceleraciÃ³n random la direcciÃ³n del vector aceleraciÃ³n surgÃ­a aleatoriamente por lo que generaba movimientos impredecibles.
- Cuando implementÃ© la aceleraciÃ³n hacia el mouse me pareciÃ³ muy interesante la manera tan sencilla en que funcionaba. En el movimiento percibÃ­ cambios de posiciÃ³n muy drasticos segÃºn la posiciÃ³n del mouse y el control del corazÃ³n dependÃ­a en gran parte del valor en la magnitud que se le podÃ­a modificar al cÃ³digo. 
  

  


  




 
  

  












